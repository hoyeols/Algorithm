'''4. 셔틀버스(난이도: 중)
카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다.
카카오의 직원은 서로를 ‘크루’라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.
이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.
셔틀은 09:00부터 총 n회 t분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 m명의 승객이 탈 수 있다.
셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다.
예를 들어 09:00에 도착한 셔틀은 자리가 있다면 09:00에 줄을 선 크루도 탈 수 있다.
일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다.
콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.

단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 23:59에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.

입력 형식
셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 최대 크루 수 m, 크루가 대기열에 도착하는 시각을 모은 배열 timetable이 입력으로 주어진다.

0 ＜ n ≦ 10
0 ＜ t ≦ 60
0 ＜ m ≦ 45
timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 HH:MM 형식으로 이루어져 있다.
크루의 도착 시각 HH:MM은 00:01에서 23:59 사이이다.
출력 형식
콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 HH:MM 형식이며, 00:00에서 23:59 사이의 값이 될 수 있다.

입출력 예제
n	t	m	timetable	answer
1	1	5	["08:00", "08:01", "08:02", "08:03"]	"09:00"
2	10	2	["09:10", "09:09", "08:00"]	"09:09"
2	1	2	["09:00", "09:00", "09:00", "09:00"]	"08:59"
1	1	5	["00:01", "00:01", "00:01", "00:01", "00:01"]	"00:00"
1	1	1	["23:59"]	"09:00"
10	60	45	["23:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59",
 "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"]	"18:00"'''

def solution(n, t, m, timetable):
	timetable = [int(time[:2]) * 60 + int(time[3:5]) for time in timetable]
	timetable.sort()

	last_time = 540 + (n - 1) * t
	for bus in range(n):
		if len(timetable) < m: #버스가 충분히 많다면 맨마지막 시간 (버스가 지나다가 중간쯤부터 여유로울 수 있으니 반복문 안에)
			return '%02d:%02d' % (last_time // 60, last_time % 60)
		if bus == n - 1:	#마지막 버스일 경우
			if timetable[0] > last_time:	#남은인원중 젤 빨리 온사람이 마지막 버스를 못 탈 경우
				return '%02d:%02d' % (last_time // 60, last_time % 60)
			if timetable[m - 1] <= last_time:	#마지막 크루원이 마지막 버스를 탈 수 있으면 그거보다 1분 작게
				time = timetable[m - 1] - 1
				return '%02d:%02d' % (time // 60, time % 60)
			for crew in range(m):	#마지막 버스에서 m명만큼 반복
				bus_arrive = 540 + bus * t
				if timetable[crew] > bus_arrive:	#마지막 버스를 놓친사람의 바로 전이 마지막으로 타는사람
					time = timetable[crew - 1] - 1	#마지막 버스에서 마지막으로 타는 사람보다 일분 전에 와야함
					return '%02d:%02d' % (time // 60, time % 60)
		for i in range(m - 1, -1, -1):	#정방향으로 반복문 진행한다면 del할시마다 인덱스가 하나씩 당겨져서 원하는 인덱스 못 얻음
			bus_arrive = 540 + bus * t
			if timetable[i] <= bus_arrive:	#크루원이 버스도착하는시간보다 작다면 제거
				del timetable[i]	#역순으로 하는이유

n, t, m, timetable = 1, 1, 5, ["08:00", "08:01", "08:02", "08:03"]
print(solution(n, t, m, timetable))
n, t, m, timetable = 2, 10, 2, ["09:10", "09:09", "08:00"]
print(solution(n, t, m, timetable))
n, t, m, timetable = 2, 1, 2, ["09:00", "09:00", "09:00", "09:00"]
print(solution(n, t, m, timetable))
n, t, m, timetable = 1, 1, 5, ["00:01", "00:01", "00:01", "00:01", "00:01"]
print(solution(n, t, m, timetable))
n, t, m, timetable = 1, 1, 1, ["23:59"]
print(solution(n, t, m, timetable))
n, t, m, timetable = 10, 60, 45, ["23:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59",
 "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"]
print(solution(n, t, m, timetable))
n, t, m, timetable = 10, 60, 10, ["17:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59",
 "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"]
print(solution(n, t, m, timetable))
